import platformio

import glob
import os
import sys

from requests import head

env = DefaultEnvironment()
try:
    import numpy as np
    from PIL import Image
except ImportError:
    env.Execute(
        env.VerboseAction(
            '$PYTHONEXE -m pip install "Pillow" "numpy"',
            "Installing ESP-IDF's Python dependencies",
        )
    )
    import numpy as np
    from PIL import Image


files = glob.glob("./images/*.png")

size = 0
header_str = ""
header_str += "#ifndef _IMAGES_H\n"
header_str += "#define _IMAGES_H\n"
header_str += "\n"
cpp_str = ""
cpp_str += "#include <avr/pgmspace.h>\n"
cpp_str += '#include "images.h"\n'
cpp_str += "\n"
for fname in files:
    print(f"Adding {fname}")
    img = np.array(Image.open(fname))
    bool_arr: np.ndarray = img[:, :, 0] == 0  # For all columns and rows, compare the 1st channel (0th index) to 0 and return a bool
    bool_arr.flatten()  # Make the multidimensional array 1-dimensional
    int_arr = np.packbits(bool_arr)  # Pretend the bools are bitmasks for bytes
    size += int_arr.size  # Accumulate the size of each image so we can prepend the header with the flash consumed
    variable_name = os.path.splitext(os.path.basename(fname))[0]
    cpp_str += f"const PROGMEM uint8_t {variable_name}[] =\n{{"
    header_str += f"extern const PROGMEM uint8_t {variable_name}[];\n"
    for i, val in enumerate(int_arr):
        if i % (img.shape[1] / 8) == 0:
            cpp_str += "\n  "
        cpp_str += f"0x{val:X}, "
    if cpp_str[-3:] == "\n  ":  # Trim the trailing newline if it exists
        cpp_str = cpp_str[:-3]
    cpp_str += "\n};\n\n"

cpp_str = f"// Autogenerated.  Takes {size:,} bytes of flash.\n" + cpp_str
header_str = f"// Autogenerated.  Takes {size:,} bytes of flash.\n" + header_str + "\n#endif"


with open("./include/images.h", "w") as f:
    f.write(header_str)

with open("./src/images.cpp", "w") as f:
    f.write(cpp_str)